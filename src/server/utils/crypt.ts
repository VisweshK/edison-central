/**
 * Implements functions to encrypt, decrypt and hash text
 */
import crypto = require("crypto");
import {promisify} from "util";

const pbkdf2 = promisify(crypto.pbkdf2);
const randomBytes = promisify(crypto.randomBytes);

/**
 * Encryption and Hashing Configuration
 */
const config = {
  /** Encryption Algorithm */
  algorithm : "aes-256-ctr",
  /** Hash algorithm */
  digest: "sha512",
  /** size of the generated hash */
  hashBytes: 32,
  /** pbkdf2 iterations */
  iterations: 70000,
  /** Encryption Key Length */
  keyLen: 32,
  /** size of salt used */
  saltBytes: 16
};

export async function genEncryptKey() {
  return (await randomBytes(config.keyLen)).toString();
}
/**
 * Encrypts given text with defined algorithm in config.
 * @param {string} text Text to encrypt
 * @param {string} password Encryption key to be used
 * @returns {string} The encrypted text
 */
export function encrypt(text: string, password: string) {
  const cipher = crypto.createCipher(config.algorithm, password);
  let crypted = cipher.update(text, "utf8", "hex");
  crypted += cipher.final("hex");
  return crypted;
}

/**
 * Decrypts given text with defined algorithm.
 * @param {string} text Text to decrypt
 * @param {string} password Key to decrypt text
 * @returns {string} The decrypted text
 */
export function decrypt(text: string, password: string) {
  const decipher = crypto.createDecipher(config.algorithm, password);
  let dec = decipher.update(text, "hex", "utf8");
  dec += decipher.final("utf8");
  return dec;
}

/**
 * Hashes password with pbkdf2. Returns a hex string in following format:
 * <saltlength><Iterations><salt><hash>
 * @param {string} password Password to hash
 * @returns {string} The salted hash as a string
 */
export async function hashPassword(password: string) {

  // generate a salt for pbkdf2
  const salt = await randomBytes(config.saltBytes);

  const hash = await pbkdf2(password,
                    salt,
                    config.iterations,
                    config.hashBytes,
                    config.digest);

  const combined = new Buffer(hash.length + salt.length + 8);

  // include the size of the salt so that we can, during verification,
  // figure out how much of the hash is salt
  combined.writeUInt32BE(salt.length, 0, true);
  // similarly, include the iteration count
  combined.writeUInt32BE(config.iterations, 4, true);

  salt.copy(combined, 8);
  hash.copy(combined, salt.length + 8);
  return combined.toString("hex");
}

/**
 * Verifies a password against a pbkdf2 hash.
 * @param {string} password The password to verify against combinedHash
 * @param {string} combinedHash The combinedHash generated by hashPassword()
 * @returns {boolean} True if the password matches the hash, else false.
 */
export async function verifyPassword(
  password: string,
  combinedHash: string) {

  // generate buffer from hash string
  const combined: Buffer = new Buffer(combinedHash, "hex");
  // extract the salt and hash from the combined buffer
  const saltBytes = combined.readUInt32BE(0);
  const hashBytes = combined.length - saltBytes - 8;
  const iterations = combined.readUInt32BE(4);
  const salt = combined.slice(8, saltBytes + 8);
  const hash = combined.toString("binary", saltBytes + 8);

  // verify the salt and hash against the password
  const verify = await pbkdf2(password,
                                   salt,
                                   iterations,
                                   hashBytes,
                                   config.digest);

  return verify.toString("binary") === hash;

}
